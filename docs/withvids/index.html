<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>AI Coding Assistant: Empowering Developers with AI</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reset.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/monokai.min.css">
  <style>
      /* Improved styling for better readability and visual appeal */
      #statusMessage {
          position: fixed;
          bottom: 60px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 1000;
          padding: 10px;
          background-color: rgba(0, 0, 0, 0.7);
          color: white;
          border-radius: 5px;
          font-size: 14px;
          max-width: 80%;
          text-align: center;
      }

      .reveal .slides {
          text-align: left;
          font-size: 1em;
          line-height: 1.4;
      }

      .reveal h1, .reveal h2, .reveal h3 {
          text-transform: none;
          margin-bottom: 0.5em;
          color: #42affa;
          text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .reveal .slides section {
          height: 100%;
          padding: 20px;
      }

      .reveal .progress {
          color: #42affa;
      }

      .reveal ul, .reveal ol {
          margin-left: 1em;
          margin-bottom: 1em;
      }

      .reveal li {
          margin-bottom: 0.5em;
      }

      .reveal .columns {
          display: flex;
          justify-content: space-between;
          flex-wrap: wrap;
      }

      .reveal .column {
          flex: 1;
          padding: 0 1em;
          min-width: 250px;
      }

      .reveal .highlight {
          color: #42affa;
          font-weight: bold;
          text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      }

      .reveal .footer {
          position: absolute;
          bottom: 1em;
          left: 1em;
          font-size: 0.5em;
          color: #888;
      }

      .reveal {
          position: relative;
          overflow: hidden;
          border-radius: 5px;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      }

      .reveal pre {
          width: 100%;
          max-height: 400px;
          overflow-y: auto;
          padding: 10px;
      }

      .reveal pre code {
          padding: 10px;
          font-size: 0.9em;
      }

      #controlsContainer {
          position: fixed;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 1000;
          display: flex;
          align-items: center;
          background-color: rgba(0, 0, 0, 0.7);
          padding: 10px;
          border-radius: 5px;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      }

      #autoplayButton {
          padding: 10px 20px;
          background-color: #42affa;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 16px;
          margin-right: 10px;
          transition: background-color 0.3s ease;
      }

      #autoplayButton:hover {
          background-color: #2980b9;
      }

      #voiceSelect {
          padding: 5px;
          font-size: 14px;
          background-color: #42affa;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
      }

      /* Responsive design improvements */
      @media (max-width: 768px) {
          .reveal .slides {
              font-size: 0.8em;
          }

          #controlsContainer {
              flex-direction: column;
              align-items: stretch;
          }

          #autoplayButton, #voiceSelect {
              margin-bottom: 10px;
          }
      }
  </style>
</head>
<body>
<div id="controlsContainer">
  <button id="autoplayButton">Autoplay: Off</button>
  <select id="voiceSelect"></select>
</div>
<div id="statusMessage"></div>
<div class="reveal">
  <div class="slides">
    <section>
      <h1>AI Coding Assistant</h1>
      <h3>Enhancing Productivity and Creativity with AI</h3>
      <p>An Open Source Project</p>
      <br>
      <p><small>Press 'Space' or 'Arrow Right' to navigate</small></p>
      <aside class="notes">
        Welcome everyone.
        Today we are discussing the Artificial Intelligence Coding Assistant, an open-source project that is changing how developers work with Artificial Intelligence.
        We will cover its key features and benefits, focusing on how it boosts productivity and creativity in coding.
        Let's explore the future of software development together.
      </aside>
    </section>
    <section>
      <h2>Agenda</h2>
      <ol>
        <li>LLM Strengths and Weaknesses</li>
        <li>Best Practices for AI Coding</li>
        <li>AI Coding Assistant Overview</li>
        <li>Generating and Modifying Code and Docs</li>
        <li>Project Generation</li>
        <li>Creating New AI Applications</li>
      </ol>
      <aside class="notes">
        Our agenda today covers six main areas.
        We will start with Large Language Model capabilities, then move on to best practices for Artificial Intelligence coding.
        We will give an overview of the Artificial Intelligence Coding Assistant, show how it generates and modifies code, discuss project generation, and finally explore creating new Artificial Intelligence applications.
        This comprehensive look will show you how to leverage Artificial Intelligence throughout the development process.
      </aside>
    </section>
    <section>
      <h2>Background: LLM Capabilities</h2>
      <p>Let's explore what LLMs are good at and where they struggle.</p>
      <aside class="notes">
        Understanding Large Language Model capabilities and limitations is key to effectively using Artificial Intelligence Coding Assistants.
        Let us begin by examining Large Language Model strengths.
      </aside>
    </section>
    <section>
      <h2>LLMs are Good at:</h2>
      <div class="columns">
        <div class="column">
          <ul>
            <li><span class="highlight">24/7 availability</span> and scalability</li>
            <li><span class="highlight">Summarizing</span> and/or <span class="highlight">Translating</span> code, text, and data</li>
            <li><span class="highlight">Pattern recognition</span>, error fixing, and parsing</li>
          </ul>
        </div>
        <div class="column">
          <ul>
            <li><span class="highlight">Answering</span> questions and dialog</li>
            <li><span class="highlight">Inference</span> and Few-shot learning</li>
            <li><span class="highlight">Fuzzy logic</span> and probabilistic reasoning</li>
          </ul>
        </div>
      </div>
      <aside class="notes">
        Large Language Models offer several advantages for coding assistance.
        They are always available and scalable, excel at summarizing and translating code, and can recognize patterns to fix errors.
        They engage in dialog, answer questions, and use inference and few-shot learning.
        Their fuzzy logic helps handle ambiguous information.
        These capabilities make Large Language Models versatile tools for various coding tasks.
      </aside>
    </section>
    <section>
      <h2>LLMs are Bad at:</h2>
      <ul>
        <li>Understanding context <span class="highlight">outside of training data</span></li>
        <li>Generating <span class="highlight">creative or novel</span> content</li>
        <li><span class="highlight">Deterministic logic</span> and reasoning</li>
        <li>Handling <span class="highlight">ambiguous instructions</span></li>
        <li>Maintaining <span class="highlight">consistent behavior</span> over long interactions</li>
      </ul>
      <aside class="notes">
        It is crucial to understand the limitations of Large Language Models.
        They struggle with context beyond their training data, potentially leading to outdated information.
        While they can combine ideas, generating truly novel content is challenging.
        Large Language Models often falter with deterministic logic, which is vital in programming.
        They can misinterpret ambiguous instructions, resulting in unexpected outputs.
        During extended interactions, they may have difficulty maintaining consistency or recalling earlier context.
        Recognizing these limitations allows us to use Large Language Models more effectively and identify when human intervention is necessary.
      </aside>
    </section>

    <section>
      <section>
        <h2>Best Practices for AI Coding</h2>
        <p>Maximize the potential of AI in your workflow:</p>
        <ul>
          <li>Utilize <span class="highlight">Markdown</span> for documentation</li>
          <li>Leverage <span class="highlight">Tools and Libraries</span> effectively</li>
          <li>Follow conventional <span class="highlight">best practices</span></li>
          <li>Manage complexity with <span class="highlight">design patterns</span></li>
          <li>Use effective <span class="highlight">prompting techniques</span></li>
        </ul>
        <aside class="notes">
          To optimize Artificial Intelligence-assisted coding, adopt these best practices.
          Use Markdown for documentation, as it is easily interpreted by both humans and Artificial Intelligence.
          Effectively leverage existing tools and libraries, with Artificial Intelligence aiding in their integration.
          Adhere to conventional best practices to help Artificial Intelligence understand and generate higher quality code.
          Employ design patterns to manage complexity, as Artificial Intelligence can recognize and implement these patterns.
          Master effective prompting techniques, as clear and specific prompts lead to better Artificial Intelligence-generated results.
          Implementing these practices fosters a more symbiotic relationship with Artificial Intelligence coding tools,
          ultimately boosting your productivity and improving code quality.
        </aside>
      </section>
    </section>
    <section>
      <h2>Future of Human Developers</h2>
      <p>As AI coding evolves, human developers will concentrate on:</p>
      <div class="columns">
        <div class="column">
          <ul>
            <li><span class="highlight">Creativity</span> and innovation</li>
            <li><span class="highlight">User experience</span> and design</li>
            <li>Addressing AI logic <span class="highlight">"blind spots"</span></li>
          </ul>
        </div>
        <div class="column">
          <ul>
            <li><span class="highlight">Interacting</span> with and testing products</li>
            <li>Providing <span class="highlight">domain-specific expertise</span></li>
          </ul>
        </div>
      </div>
      <aside class="notes">
        As Artificial Intelligence becomes more prevalent in coding, human developers will evolve to focus on areas where they excel.
        They will drive creativity and innovation, bringing fresh ideas to the table.
        User experience and design will remain human-centric, requiring empathy and deep understanding of user needs.
        Developers will also play a crucial role in identifying and addressing Artificial Intelligence blind spots, ensuring code logic and security.
        Human insight will still be essential for product interaction and real-world testing.
        Additionally, domain-specific expertise will be invaluable in guiding Artificial Intelligence tools and interpreting their outputs in specific contexts.
        In essence, Artificial Intelligence will not replace developers but will augment their capabilities,
        allowing them to concentrate on higher-level, more creative aspects of software development.
      </aside>
    </section>

    <section>
      <section>
        <h2>AI Coding Assistant: An Overview</h2>
        <ul>
          <li><span class="highlight">Free and open-source</span></li>
          <li>Independent project (not endorsed by my employer)</li>
          <li>Case study for AI coding capabilities</li>
          <li><span class="highlight">IntelliJ plugin</span> integrating AI capabilities</li>
          <li>Features: <span class="highlight">code generation, documentation, task planning</span></li>
          <li>Uses <span class="highlight">Skyenet-based Apps</span> (web UI)</li>
        </ul>
        <aside class="notes">
          Let us explore the Artificial Intelligence Coding Assistant in more detail.
          This tool is a free and open-source project, encouraging community involvement and maintaining transparency.
          It is important to note that this is an independent project, not affiliated with or endorsed by any company.
          The assistant serves as a practical case study, demonstrating Artificial Intelligence potential in coding.
          Implemented as an IntelliJ plugin, it integrates seamlessly into your development environment.
          Its key features include code generation, documentation creation, and task planning.
          The assistant leverages Skyenet-based Apps, offering a user-friendly web interface for interactions.
          This tool marks a significant advancement in bringing Artificial Intelligence capabilities directly into the developer's workflow,
          potentially transforming how we approach coding tasks.
        </aside>
      </section>
      <section>
        <h2>Key Features</h2>
        <ul>
          <li>Open-source and transparent (Apache 2.0 license)</li>
          <li>Multi-model and multi-provider support</li>
          <li>Based on explicit calls, not autocomplete</li>
          <li>Focus on interactive AI agents for complex tasks</li>
          <li>Strong emphasis on patching support</li>
        </ul>
        <aside class="notes">
          The Artificial Intelligence Coding Assistant stands out with several key features.
          It is open-source, ensuring transparency and community involvement.
          It supports multiple Artificial Intelligence models and providers for flexibility.
          Unlike autocomplete-based tools, it uses explicit calls for better control.
          The assistant focuses on interactive Artificial Intelligence agents for complex tasks, going beyond simple code completion.
          Lastly, it emphasizes patching support for seamless integration of Artificial Intelligence suggestions.
          These features create a powerful, adaptable tool for various coding scenarios and preferences.
        </aside>
      </section>

      <section>
        <h2>What is Skyenet?</h2>
        <ul>
          <li><span class="highlight">Websocket-based</span> AI agent platform</li>
          <li>Creates and manages <span class="highlight">AI-powered applications</span></li>
          <li>Facilitates <span class="highlight">interaction</span> between AI actors and users</li>
          <li>Provides Java's <span class="highlight">dynamic execution</span> facilities</li>
          <li>Integrates with <span class="highlight">various AI models</span> and data sources</li>
        </ul>
        <aside class="notes">
          Skyenet is the foundation of the Artificial Intelligence Coding Assistant.
          It is a websocket-based platform enabling real-time, two-way communication.
          Skyenet excels at creating and managing Artificial Intelligence-powered applications and facilitates smooth interactions between Artificial Intelligence models and users.
          It utilizes Java dynamic execution capabilities for flexible code handling and can integrate with various Artificial Intelligence models and data sources.
          This versatile platform provides a robust base for the Artificial Intelligence Coding Assistant, enhancing its capabilities and performance.
        </aside>
      </section>
      <section>
        <h2>One of Many AI Tools</h2>
        <div class="columns">
          <div class="column">
            <ul style="list-style-type: none;">
              <li>🚀 <strong>GitHub Copilot:</strong> Code completion focus</li>
              <li>☁️ <strong>Amazon Q:</strong> Cloud-based AI assistance</li>
              <li>🛠️ <strong>JetBrains AI Assistant:</strong> IDE-integrated</li>
            </ul>
          </div>
          <div class="column" style="border-left: 1px solid #42affa; padding-left: 2em;">
            <ul>
              <li><strong>Microsoft AutoGen:</strong> AI agent framework</li>
              <li><strong>LangChain:</strong> AI application framework</li>
            </ul>
          </div>
        </div>
        <aside class="notes">
          The Artificial Intelligence Coding Assistant is part of a diverse ecosystem of Artificial Intelligence tools for developers.
          GitHub Copilot excels in code completion, while Amazon Q specializes in A W S related assistance.
          JetBrains offers I D E integration, and Microsoft AutoGen focuses on Artificial Intelligence agent creation.
          LangChain provides a framework for Large Language Model-based applications.
          Our Artificial Intelligence Coding Assistant aims to be a versatile, open-source solution that complements existing developer workflows.
        </aside>
      </section>
    </section>

    <section>
      <section>
        <h2>Generation Methods</h2>
        <ol>
          <li><span class="highlight">Basic Generation</span> (Code Chat)</li>
          <li><span class="highlight">Editing Files</span> with Patches</li>
          <li><span class="highlight">Mermaid Diagrams</span> in Markdown</li>
          <li><span class="highlight">Reveal.js Presentations</span></li>
          <li><span class="highlight">Mass Actions</span></li>
        </ol>
        <aside class="notes">
          Our Artificial Intelligence Coding Assistant provides a range of generation methods to suit various coding needs.
          It offers interactive code creation through Basic Generation, systematic code modifications with Editing Files and Patches,
          visual representations using Mermaid Diagrams, assistance in creating Reveal js Presentations for documentation, and Mass Actions for large-scale changes.
          This versatility allows developers to choose the most appropriate method for their specific tasks and preferences.
        </aside>
      </section>
      <section>
        <h2>Coding Chat</h2>
        <ul>
          <li>Use <span class="highlight">natural language</span> to generate code</li>
          <li>Supports <span class="highlight">Markdown</span> and code formatting</li>
          <li>Interactive <span class="highlight">code generation</span> and editing</li>
          <li>Demo: Provide a user manual for a script</li>
        </ul>
        <aside class="notes">
          The Coding Chat feature is a powerful tool for developers.
          It allows you to describe your coding needs in natural language, making it accessible even for complex tasks.
          The chat supports Markdown and code formatting, ensuring that the generated code is well-structured and readable.
          As a demonstration, we'll show how to use this feature to generate a user manual for a script, showcasing its versatility beyond just code generation.
          This feature bridges the gap between natural language and code, making it easier for developers to translate their ideas into functional code quickly and efficiently.
        </aside>
      </section>
      <section>
        <h2>Editing Files with Patches</h2>
        <ul>
          <li>Apply <span class="highlight">patches</span> to codebase</li>
          <li>Uses custom patching logic to handle unpredictable LLM responses</li>
          <li>Provides verification to <span class="highlight">preview</span> the result of the patch</li>
          <li>Demo: Use <span class="highlight">Patch Files</span> to add <span class="highlight">Mermaid syntax</span>
            to Markdown files
          </li>
        </ul>
        <aside class="notes">
          The Editing Files with Patches feature is a sophisticated way to apply Artificial Intelligence-suggested changes.
          It allows you to apply patches directly to your codebase, streamlining the process of implementing Artificial Intelligence recommendations.
          We've implemented custom patching logic to handle the sometimes unpredictable nature of Large Language Model responses, ensuring smooth integration.
          Before applying any changes, you can preview the results, giving you full control over the modifications.
          In our demo, we'll show how to use this feature to add Mermaid syntax to Markdown files, illustrating its potential for enhancing documentation.
          This feature combines the power of Artificial Intelligence suggestions with the precision of controlled code modifications, offering a balanced approach to Artificial
          Intelligence-assisted coding.
        </aside>
      </section>
      <section>
        <h2>Reveal.js Presentations</h2>
        <ul>
          <li>Generate <span class="highlight">presentation outlines</span> with AI</li>
          <li>Demo: Use <span class="highlight">Generate Related File</span> for initial structure</li>
          <li>Customize and refine slides with <span class="highlight">Patch Chat</span></li>
        </ul>
        <aside class="notes">
          Our Artificial Intelligence Coding Assistant can also be used to create Reveal js Presentations.
          This allows you to generate entire presentation outlines using AI, helping you quickly structure your thoughts.
          We'll show you how to use the 'Generate Related File' action to create an initial presentation structure, and then use Patch Chat to customize individual slides.
          This extends our tool's utility beyond coding, aiding in content creation and presentation prep.
          It's especially helpful for developers needing to present their work or explain complex coding concepts.
        </aside>
      </section>
      <section>
        <h2>Mass Actions</h2>
        <ul>
          <li>Use <span class="highlight">GenerateDocumentationAction</span> for multiple files</li>
          <li>Apply <span class="highlight">MassPatchAction</span> for consistent changes</li>
          <li>Streamline <span class="highlight">large-scale documentation</span> efforts</li>
        </ul>
        <aside class="notes">
          Let's talk about Mass Actions, a powerful set of features for handling large-scale changes.
          The GenerateDocumentationAction automatically generates documentation for multiple files at once, speeding up the process significantly.
          MassPatchAction allows you to apply consistent changes across numerous files, ensuring uniformity in your codebase.
          These features are invaluable for streamlining large-scale documentation efforts and maintaining up-to-date, comprehensive documentation.
          Mass Actions showcase how our Artificial Intelligence Coding Assistant can handle not just individual tasks, but also project-wide changes, boosting productivity for
          larger codebases and team projects.
        </aside>
      </section>
    </section>
    <section>
      <section data-auto-animate>
        <h3>Project Generation Tools</h3>
        <ul>
          <li><span class="highlight">Plan-Ahead action</span>
            <ul>
              <li>Create multi-tier applications</li>
              <li>Generate project structures</li>
            </ul>
          </li>
          <li><span class="highlight">Iterative Auto-fixing</span>
            <ul>
              <li>Use CommandAutofixAction for build/test commands</li>
              <li>Automatically fix issues based on command output</li>
            </ul>
          </li>
        </ul>
        <aside class="notes">
          Our Project Generation Tools elevate AI assistance to new heights.
          The Plan-Ahead action acts as an AI architect, creating multi-tier applications and generating entire project structures.
          Iterative Auto-fixing uses CommandAutofixAction to run commands and automatically fix issues.
          These tools showcase Artificial Intelligence's ability to assist in planning and maintaining entire projects, significantly reducing setup and maintenance time.
        </aside>
      </section>
      <section data-auto-animate>
        <h3>Plan-Ahead Action</h3>
        <ul>
          <li>Define complex tasks or project goals</li>
          <li>Generate step-by-step plans using Artificial Intelligence</li>
          <li>Execute commands in your project's environment</li>
          <li>Analyze results and adjust plans dynamically</li>
        </ul>
        <aside class="notes">
          The Plan-Ahead Action is a powerful feature that allows you to define complex tasks or project goals, guiding the Artificial Intelligence's direction.
          It generates detailed plans, executes commands in your environment, and dynamically adjusts based on results.
          This creates an Artificial Intelligence-assisted feedback loop of planning, execution, and refinement, essentially providing you with an Artificial Intelligence project
          manager that continuously optimizes your development process.
        </aside>
      </section>
      <section>
        <h3>Iterative Auto-fixing</h3>
        <ul>
          <li>Run system commands and automatically fix issues</li>
          <li>Customize command execution and working directory</li>
          <li>Intelligent error handling based on exit codes</li>
          <li>Artificial Intelligence-driven problem-solving for development workflow</li>
        </ul>
        <aside class="notes">
          Iterative Auto-fixing is a powerful feature for debugging and maintaining code.
          It runs system commands like build or test scripts and automatically fixes issues, saving hours of manual debugging.
          You can customize command execution and specify the working directory to fit your workflow.
          The feature uses intelligent error handling based on exit codes for nuanced responses.
          Essentially, it's Artificial Intelligence-driven problem-solving for your development process, automatically identifying and fixing issues,
          which can greatly streamline development, especially for large or complex projects.
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h2>Making Changes to Code</h2>
        <ul>
          <li><span class="highlight">Apply Patch:</span> Salvage a diff produced in chat</li>
          <li><span class="highlight">"Do Something":</span> Natural language-based code changes</li>
        </ul>
        <aside class="notes">
          Let's explore two powerful ways to make code changes with our Artificial Intelligence Coding Assistant.
          The Apply Patch feature lets you salvage and apply diffs produced in chat, useful for implementing discussed changes directly.
          The "Do Something" action allows you to describe code changes in natural language, which the AI then interprets and implements.
          These features efficiently bridge the gap between discussion and implementation, quickly translating ideas into code changes.
        </aside>
      </section>
      <section>
        <h3>Apply Patch Example</h3>
        <ul>
          <li>Sometimes an LLM response isn't correctly linked to a file or is not recognized</li>
          <li>The "Apply Patch" allows you to cut and paste the diff and apply it to a file</li>
          <li>This uses the same "fuzzy" patching logic used elsewhere to handle LLM diffs</li>
        </ul>
        <aside class="notes">
          The Apply Patch feature addresses situations where an LLM response isn't correctly linked to a file or recognized by the system,
          which can happen due to the flexible nature of Artificial Intelligence generated content.
          It allows you to manually cut and paste the diff and apply it to a file of your choice, giving you more control over changes.
          The feature uses "fuzzy" patching logic, making it robust enough to handle slight inconsistencies in diff formats.
          This ensures that even if automatic linking fails, you can still easily apply AI-suggested changes to your code, maintaining a smooth workflow.
        </aside>
      </section>
      <section>
        <h3>"Do Something" Action</h3>
        <ul>
          <li>Code modifications using a 2-step agent with access to the entire project</li>
          <li>Artificial Intelligence interprets, plans simple tasks, and applies changes to codebase</li>
          <li>Useful for quick fixes and moderately complex tasks</li>
        </ul>
        <aside class="notes">
          The "Do Something" action is a powerful feature that leverages a two-step Artificial Intelligence agent with full project access.
          This agent interprets your request, plans the necessary steps, and applies changes directly to your codebase.
          It's particularly effective for quick fixes and moderately complex tasks, allowing you to describe your needs in natural language.
          This feature demonstrates how Artificial Intelligence can enhance software development,
          enabling developers to focus on high-level problem-solving while the Artificial Intelligence manages code implementation details.
        </aside>
      </section>
    </section>

    <section>
      <h2>Troubleshooting Tips</h2>
      <ul>
        <li>Adjust temperature setting for creativity/randomness</li>
        <li>Check selected model for task alignment</li>
        <li>Provide clear, specific instructions</li>
        <li>Look at actual requests/responses</li>
        <li>Provide an example of your desired output</li>
      </ul>
      <aside class="notes">
        To optimize your experience with the Artificial Intelligence Coding Assistant, consider these troubleshooting tips:
        Adjust the temperature setting to control the Artificial Intelligence's creativity and randomness.
        Ensure you're using the most appropriate model for your specific task.
        Provide clear and precise instructions to help the Artificial Intelligence understand your intent.
        If results are unexpected, examine the actual requests and responses to gain insight into the Artificial Intelligence's interpretation.
        Offering an example of your desired output can significantly improve results.
        Remember that working with Artificial Intelligence is a skill that improves with practice,
        so don't hesitate to experiment and refine your approach to find what works best for your projects.
      </aside>
    </section>
    <section data-auto-animate>

      <section>
        <h2>Creating New AI Applications</h2>
        <p>Using this project to create new <span class="highlight">AI applications</span></p>
        <p><span class="highlight">Not:</span> Using this project's AI to create new applications</p>
        <aside class="notes">
          This section focuses on how to use the Artificial Intelligence Coding Assistant framework to develop new Artificial Intelligence applications.
          We're not discussing using the AI to create applications for you,
          but rather how to leverage the framework and its components to build your own AI-powered tools.
          This capability expands the project's utility beyond simple coding assistance,
          opening up possibilities for creating diverse Artificial Intelligence-driven applications.
        </aside>
      </section>
      <section>
        <h3>Actors and Actor Apps</h3>
        <ul>
          <li>Define <span class="highlight">AI</span>
            <ul>
              <li>SimpleActor, CodingActor, ImageActor, etc.</li>
            </ul>
          </li>
          <li>Use MetaAgentApp for rapid prototyping</li>
          <li>Extend BaseActor class for custom AI actors</li>
        </ul>
        <aside class="notes">
          Our Actor system is the foundation for creating Artificial Intelligence applications.
          We offer various specialized Actors like SimpleActor for text, CodingActor for code tasks, and ImageActor for images.
          The MetaAgentApp enables quick prototyping and testing of different Actor configurations.
          For custom needs, you can extend the BaseActor class
          This versatile system supports a wide range of Artificial Intelligence applications, from chatbots to code analyzers and image generators, all within a unified framework.
        </aside>
      </section>
      <section data-auto-animate>
        <h3>Plan Tasks and Extensibility</h3>
        <ul>
          <li>Integrate new task types for added functionality</li>
          <li>Develop applications with plan-based task execution</li>
        </ul>
        <aside class="notes">
          Our framework supports complex, multi-step Artificial Intelligence applications.
          You can integrate new task types for expanded capabilities, such as data processing, analytics, or external system integration.
          The plan-based task execution system helps break down complex problems into manageable steps, each handled by appropriate Artificial Intelligence actors.
          This extensibility allows your Artificial Intelligence applications to evolve with your needs without major code changes.
          These features enable the creation of sophisticated Artificial Intelligence applications capable of handling complex workflows and decision-making processes,
          going well beyond basic query-response interactions.
        </aside>
      </section>
    </section>
    <section>
      <h2>Thank You!</h2>
      <p>Explore AI Coding Assistant and enhance your development workflow</p>
      <p>Questions? Comments? Let's discuss!</p>
      <p><small>For more information, visit our <a href="https://github.com/SimiaCryptus/intellij-aicoder"
                                                   target="_blank">GitHub repository</a></small></p>
    </section>
  </div>
  <div class="footer">
    AI Coding Assistant - An Open Source Project
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/notes/notes.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/markdown/markdown.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/zoom/zoom.min.js"></script>
<script>
    let synth = window.speechSynthesis;
    let isAutoPlaying = false;
    let utterances = [];
    let currentUtteranceIndex = 0;
    const autoplayButton = document.getElementById('autoplayButton');
    const voiceSelect = document.getElementById('voiceSelect');
    const statusMessage = document.getElementById('statusMessage');
    const debugLog = [];

    function log(message) {
        console.log(message);
        debugLog.push(`${new Date().toISOString()}: ${message}`);
        if (debugLog.length > 100) debugLog.shift();
        statusMessage.textContent = message;
        setTimeout(() => {
            statusMessage.textContent = '';
        }, 3000);
    }

    function displayDebugLog() {
        alert(debugLog.join('\n'));
    }

    function createUtterances(text) {
        let sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
        return sentences.map(sentence => {
            let utterance = new SpeechSynthesisUtterance(sentence.trim());
            utterance.lang = 'en-US';
            utterance.volume = 1;
            utterance.rate = 1;
            utterance.pitch = 1;
            const selectedVoice = voiceSelect.value;
            if (selectedVoice) {
                utterance.voice = synth.getVoices().find(voice => voice.name === selectedVoice);
            }
            return utterance;
        });
    }


    function speakNotes() {
        log('Entering speakNotes function');
        let notes = Reveal.getCurrentSlide().querySelector('aside.notes');
        if (notes) {
            let text = notes.textContent.replace(/\s+/g, ' ').trim();
            log(`Notes text: ${text.substring(0, 50)}...`);
            utterances = createUtterances(text);
            log(`Created ${utterances.length} utterances`);
            currentUtteranceIndex = 0;
            utterances.forEach(utterance => {
                utterance.onend = onUtteranceEnd;
            });
            try {
                synth.cancel();  // Cancel any ongoing speech
                synth.speak(utterances[currentUtteranceIndex]);
                log('Started speaking first utterance');
            } catch (error) {
                log(`Error in synth.speak: ${error.message}`);
            }
        } else {
            if (isAutoPlaying) {
                log('No notes found, moving to next slide in 1 second');
                setTimeout(() => Reveal.next(), 1000);
            } else {
                log('No notes found and not autoplaying');
            }
        }
    }

    // Check if speech synthesis is supported and initialize voices
    function initSpeech() {
        if ('speechSynthesis' in window) {
            log('Speech synthesis is supported');
            listVoices();
            synth.onvoiceschanged = listVoices;
            voiceSelect.addEventListener('change', () => {
                if (isAutoPlaying) {
                    stopSpeaking();
                    speakNotes();
                }
            });
        } else {
            log('Speech synthesis is not supported in this browser');
        }
    }

    // Call initSpeech when the page loads
    window.addEventListener('load', initSpeech);

    // List available voices
    function listVoices() {
        let voices = synth.getVoices();
        log(`Available voices: ${voices.length}`);
        voiceSelect.innerHTML = '';
        voices.forEach((voice, index) => {
            log(`Voice ${index}: ${voice.name} (${voice.lang})`);
            const option = document.createElement('option');
            option.value = voice.name;
            option.textContent = `${voice.name} (${voice.lang})`;
            voiceSelect.appendChild(option);
        });
        if (voices.length > 0) {
            voiceSelect.value = voices.find(voice => voice.lang.startsWith('en-'))?.name || voices[0].name;
        }
    }

    // Call listVoices when voices are loaded
    if (synth.onvoiceschanged !== undefined) {
        synth.onvoiceschanged = listVoices;
    }

    function onUtteranceEnd() {
        log('Utterance ended');
        currentUtteranceIndex++;
        if (currentUtteranceIndex < utterances.length) {
            try {
                synth.speak(utterances[currentUtteranceIndex]);
                log(`Speaking utterance ${currentUtteranceIndex + 1} of ${utterances.length}`);
            } catch (error) {
                log(`Error in synth.speak: ${error.message}`);
            }
        } else {
            if (isAutoPlaying) {
                log('All utterances finished, moving to next slide in 1 second');
                setTimeout(() => Reveal.next(), 1000);
            } else {
                log('All utterances finished, autoplay is off');
            }
        }
    }

    function stopSpeaking() {
        log('Stopping speech');
        try {
            synth.cancel();
        } catch (error) {
            log(`Error in synth.cancel: ${error.message}`);
        }
        utterances = [];
        currentUtteranceIndex = 0;
    }

    function toggleAutoplay() {
        log(`Toggling autoplay. Current state: ${isAutoPlaying}`);
        isAutoPlaying = !isAutoPlaying;
        if (isAutoPlaying) {
            autoplayButton.textContent = 'Autoplay: On';
            speakNotes();
        } else {
            stopSpeaking();
            autoplayButton.textContent = 'Autoplay: Off';
        }
    }

    document.addEventListener('keydown', (event) => {
        if (event.key === 'a' || event.key === 'A') {
            log('Autoplay toggled by keyboard');
            toggleAutoplay();
        } else if (event.key === 'd' || event.key === 'D') {
            displayDebugLog();
        }
    });
    autoplayButton.addEventListener('click', () => {
        log('Autoplay toggled by button click');
        toggleAutoplay();
    });

    Reveal.on('slidechanged', event => {
        log('Slide changed');
        if (isAutoPlaying) {
            setTimeout(() => {
                stopSpeaking();
                speakNotes();
            }, 100);
        }
    });
</script>
<script>
    // More info about initialization & config:
    // * https://revealjs.com/initialization/
    // * https://revealjs.com/config/
    Reveal.initialize({
        hash: true,
// Plugins configuration
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealZoom],
        navigationMode: 'linear',
// Additional configuration options
        slideNumber: true,
        progress: true,
        transition: 'slide',
        transitionSpeed: 'fast',
        autoPlayMedia: true,
        autoSlide: 0,
        center: false,
        controlsTutorial: true,
        zoom: {
            maxScale: 2.0,
            pan: false
        },
        keyboard: {
            65: toggleAutoplay, // 'a' key
            68: displayDebugLog // 'd' key
        },
    });

</script>
</body>